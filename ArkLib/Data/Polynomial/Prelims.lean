/-
Copyright (c) 2024-2025 ArkLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Katerina Hristova, Ilia Vlasov
-/

import Mathlib.Algebra.Polynomial.Basic
import Mathlib.Algebra.Polynomial.Bivariate
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.Algebra.Polynomial.Eval.Irreducible
import Mathlib.FieldTheory.RatFunc.Basic
import Mathlib.FieldTheory.Separable
import Mathlib.RingTheory.Ideal.Span
import Mathlib.RingTheory.Polynomial.Resultant.Basic

/-!
  # Preliminary Definitions and Theorems on polynomials and rings of rational functions.

  In this file, we state the needed definition and lemmas from general polynomial theory and
  commutative algebra needed to state and/or prove results on rational functions and bivariate
  polynomials.

  We divide the file into three sections : Univariate, containing results on univariate polynomials,
  Ideal, containing results relating rings and their ideals, and RatFunc, containing some
  preliminaries relating rational functions to polynomials.

  ## Main Definitions
  -- In Univariate, we define a discriminant of a polynomial and state lemmas relating discriminants
  to resultants and separability. -- In Ideal, we define principal ideals, and state the well-known
  result from commutative algebra that a principal ideal in a polynomial ring is maximal if and only
  if it is generated by an irreducible polynomial. -- In RatFunc, we define the needed algebra
  homomorphisms enabling us to lift univariate and bivariate polynomials to rational functions.

  TODO: if / when this file gets too large, we need to split it into smaller files (esp. since the
  definitions are distinct)
-/

open Polynomial
open Polynomial.Bivariate

namespace Univariate

section

/-- Discriminant of a univariate polynomial. -/
noncomputable def discriminant {F : Type} [Field F] [Inhabited F] (f : F[X]) : F :=
  1/f.leadingCoeff * Polynomial.resultant f (Polynomial.derivative f)

/-- The resultant of a polynomial is divisible by its leading coefficient. -/
lemma resultant_is_divisible_by_leadingCoeff {F : Type} [CommRing F] [Inhabited F] (f : F[X])
  : ∃ r',
    Polynomial.resultant f (Polynomial.derivative f) = f.leadingCoeff * r'
    := by sorry

/-- A polynomial is separable if and only if its discriminant is non-zero. -/
lemma separable_iff_discr_eq_zero {F : Type} [Field F] [Inhabited F] (f : F[X]) :
  f.Separable ↔ discriminant f ≠ 0 := by
  unfold discriminant
  constructor
  · intro h
    have hne : f ≠ 0 := fun hf => by subst hf; exact not_isCoprime_zero_zero h
    exact mul_ne_zero (div_ne_zero one_ne_zero (leadingCoeff_ne_zero.mpr hne))
      (resultant_ne_zero f (derivative f) h)
  · intro h
    have hres : resultant f (derivative f) ≠ 0 := right_ne_zero_of_mul h
    exact of_not_not (fun hns => hres
      (resultant_eq_zero_iff.mpr ⟨Or.inl (fun hf => by simp [hf] at h), hns⟩))

end
end Univariate

namespace Ideal
section

/-- A principal ideal is an ideal generated by a single element. -/
def principalIdeal {F : Type} [Semiring F] (f : F) : Ideal F := Ideal.span {f}

/-
A principal ideal in a polynomial ring is maximal if and only if its generator is
an irreducble polynomial.
-/
lemma principal_is_maximal_iff_irred {F : Type} [Field F] (f : F[X]) :
  (principalIdeal f).IsMaximal ↔ Irreducible f := by
    constructor <;> intro h;
    · -- If the ideal generated by f is maximal, then f is non-zero.
      have h_nonzero : f ≠ 0 := by
        intro hf;
        simp_all +decide [ Ideal.isMaximal_iff ];
        simp_all +decide [ principalIdeal ];
        specialize h ( Ideal.span { Polynomial.X } ) Polynomial.X ; simp_all +decide [ Ideal.mem_span_singleton ];
        exact absurd ( Polynomial.X_dvd_iff.mp h ) ( by norm_num );
      -- If the ideal generated by f is maximal, then f is prime.
      have h_prime : Prime f := by
        rw [ ← Ideal.span_singleton_prime h_nonzero ];
        exact h.isPrime;
      exact h_prime.irreducible;
    · rw [ Ideal.isMaximal_iff ];
      constructor;
      · exact fun h' => h.not_isUnit <| isUnit_of_dvd_one <| Ideal.mem_span_singleton.mp h';
      · intro J x hJ hx hxJ
        have h_coprime : IsCoprime f x := by
          exact h.coprime_iff_not_dvd.mpr fun h' => hx <| Ideal.mem_span_singleton.mpr h';
        rcases h_coprime with ⟨ a, b, h ⟩;
        exact h.symm ▸ J.add_mem ( J.mul_mem_left a ( hJ ( Ideal.subset_span ( Set.mem_singleton f ) ) ) ) ( J.mul_mem_left b hxJ )

end
end Ideal

namespace ToRatFunc
noncomputable section

/-- The algebra map embedding the univariate polynomial ring into its ring of rational functions. -/
def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] →+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)


/-- The algebra map embedding the bivariate polynomial ring into its ring of rational functions. -/
def bivPolyHom {F : Type} [CommRing F] [IsDomain F] :
  Polynomial (F[X]) →+* Polynomial (RatFunc F) := Polynomial.mapRingHom (univPolyHom)

end
end ToRatFunc
