/-
Copyright (c) 2024-2025 ArkLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import Mathlib.Init
import ArkLib.Data.Hash.DuplexSponge

/-!
  # Domain Separator

  This file contains the API for domain separators as defined in the
  [spongefish](https://github.com/arkworks-rs/spongefish) Rust library.

  The API is designed to be as close as possible to the Rust implementation (as of June 22, 2025).

  A domain separator is a string that specifies the protocol in a simple,
  non-ambiguous, human-readable format. A typical example is the following:

  ```text
      domain-separator A32generator A32public-key R A32commitment S32challenge A32response
  ```
  The domain-separator is a user-specified string uniquely identifying the end-user application
  (to avoid cross-protocol attacks).
  The letter `A` indicates the absorption of a public input (an `ABSORB`), while the letter `S`
  indicates the squeezing (a `SQUEEZE`) of a challenge.
  The letter `R` indicates a ratcheting operation: ratcheting means invoking the hash function
  even on an incomplete block.
  It provides forward secrecy and allows it to start from a clean rate.
  After the operation type, is the number of elements in base 10 that are being absorbed/squeezed.
  Then, follows the label associated with the element being absorbed/squeezed. This often comes
  from the underlying description of the protocol. The label cannot start with a digit or contain
  the NULL byte.

  NOTE: this file is generated by Claude 4 Sonnet and has not been fully proof-read.
-/

/-- Errors that can occur during domain separator operations.

Rust interface:
```rust
pub struct DomainSeparatorMismatch(String);
```
-/
structure DomainSeparatorMismatch where
  message : String
deriving Inhabited, DecidableEq, Repr

/-- The domain separator of an interactive protocol.

Rust interface:
```rust
#[derive(Clone)]
pub struct DomainSeparator<H = crate::DefaultHash, U = u8>
where
    U: Unit,
    H: DuplexSpongeInterface<U>,
{
    /// Encoded domain separator string representing the sequence of sponge operations.
    io: String,
    /// Marker for the sponge hash function and unit type used.
    _hash: PhantomData<(H, U)>,
}
```

The struct [`DomainSeparator`] guarantees the creation of a valid domain separator string,
whose lengths are coherent with the types described in the protocol. No information about
the types themselves is stored in a domain separator.
This means that [`ProverState`] or [`VerifierState`] instances can generate successfully
a protocol transcript respecting the length constraint but not the types.
-/
structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
  /-- Encoded domain separator string representing the sequence of sponge operations. -/
  io : String
deriving Repr

namespace DomainSeparator

/-- The null character separator between operations in the domain separator (unicode/ASCII value 0)
  and as such is the only forbidden character in labels. -/
abbrev SEP_CHAR : Char := Char.ofNat 0

/-- The null byte separator between operations in the domain separator (unicode/ASCII value 0)
  and as such is the only forbidden character in labels. -/
abbrev SEP_BYTE : String := sorry -- ⟨[SEP_CHAR]⟩

/-- Sponge operations.

Rust interface:
```rust
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum Op {
    /// Indicates absorption of `usize` lanes.
    ///
    /// In a tag, absorb is indicated with 'A'.
    Absorb(usize),
    /// Indicates processing of out-of-band message
    /// from prover to verifier.
    ///
    /// This is useful for e.g. adding merkle proofs to the proof.
    Hint,
    /// Indicates squeezing of `usize` lanes.
    ///
    /// In a tag, squeeze is indicated with 'S'.
    Squeeze(usize),
    /// Indicates a ratchet operation.
    ///
    /// For sponge functions, we squeeze sizeof(capacity) lanes
    /// and initialize a new state filling the capacity.
    /// This allows for a more efficient preprocessing, and for removal of
    /// private information stored in the rate.
    Ratchet,
}
```
-/
inductive Op where
  /-- Indicates absorption of `count` lanes. In a tag, absorb is indicated with 'A'. -/
  | Absorb (count : Nat)
  /-- Indicates processing of out-of-band message from prover to verifier.
    This is useful for e.g. adding merkle proofs to the proof. -/
  | Hint
  /-- Indicates squeezing of `count` lanes.
    In a tag, squeeze is indicated with 'S'. -/
  | Squeeze (count : Nat)
  /-- Indicates a ratchet operation.
    For sponge functions, we squeeze sizeof(capacity) lanes
    and initialize a new state filling the capacity.
    This allows for a more efficient preprocessing, and for removal of
    private information stored in the rate. -/
  | Ratchet
deriving DecidableEq, Repr

namespace Op

/-- Construct a new `Op` from a character `id` and a count number `count : Option Nat`.
Returns error if the combination of `(id, count)` is not correct. -/
def new (id : Char) (count : Option Nat) : Except DomainSeparatorMismatch Op :=
  match (id, count) with
  | ('A', some c) => if c > 0 then pure (Absorb c) else .error ⟨"Invalid tag"⟩
  | ('H', none) => pure Hint
  | ('H', some 0) => pure Hint
  | ('R', none) => pure Ratchet
  | ('R', some 0) => pure Ratchet
  | ('S', some c) => if c > 0 then pure (Squeeze c) else .error ⟨"Invalid tag"⟩
  | _ => .error ⟨"Invalid tag"⟩

end Op

variable {H : Type*} {U : Type} [SpongeUnit U] [DuplexSpongeInterface U H]

/-- Create a new DomainSeparator with the domain separator.

Rust interface:
```rust
pub fn new(session_identifier: &str) -> Self
```
-/
def new (sessionIdentifier : String) : Except DomainSeparatorMismatch (DomainSeparator U H) :=
  if sessionIdentifier.contains SEP_CHAR then
    .error ⟨"Domain separator cannot contain the separator BYTE."⟩
  else
    pure { io := sessionIdentifier }

/-- Create a DomainSeparator from a string directly.

Rust interface:
```rust
pub const fn from_string(io: String) -> Self
```
-/
def fromString (io : String) : DomainSeparator U H :=
  { io := io }

/-- Absorb `count` native elements.

Rust interface:
```rust
pub fn absorb(self, count: usize, label: &str) -> Self
```
-/
def absorb (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  -- TODO: Add assertions:
  -- - count > 0
  -- - label doesn't contain SEP_CHAR
  -- - label doesn't start with a digit
  { io := ds.io ++ SEP_BYTE ++ s!"A{count}" ++ label }

/-- Hint `count` native elements.

Rust interface:
```rust
pub fn hint(self, label: &str) -> Self
```
-/
def hint (ds : DomainSeparator U H) (label : String) : DomainSeparator U H :=
  -- TODO: Add assertion that label doesn't contain SEP_CHAR
  { io := ds.io ++ SEP_BYTE ++ "H" ++ label }

/-- Squeeze `count` native elements.

Rust interface:
```rust
pub fn squeeze(self, count: usize, label: &str) -> Self
```
-/
def squeeze (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  -- TODO: Add assertions:
  -- - count > 0
  -- - label doesn't contain SEP_CHAR
  -- - label doesn't start with a digit
  { io := ds.io ++ SEP_BYTE ++ s!"S{count}" ++ label }

/-- Ratchet the state.

Rust interface:
```rust
pub fn ratchet(self) -> Self
```
-/
def ratchet (ds : DomainSeparator U H) : DomainSeparator U H :=
  { io := ds.io ++ SEP_BYTE ++ "R" }

/-- Return the domain separator as bytes.

Rust interface:
```rust
pub fn as_bytes(&self) -> &[u8]
```
-/
def asBytes (ds : DomainSeparator U H) : ByteArray :=
  ds.io.toUTF8

/-- Parse the given domain separator into a sequence of [`Op`]'s.

Rust interface:
```rust
pub(crate) fn finalize(&self) -> VecDeque<Op>
```
-/
def finalize (ds : DomainSeparator U H) : Array Op :=
  let parts := ds.io.splitOn SEP_BYTE
  -- skip session identifier (head), parse remaining parts into ops, dropping malformed ones
  let parseDigits (cs : List Char) : Nat × List Char :=
    let rec go : Nat → List Char → Nat × List Char
    | acc, [] => (acc, [])
    | acc, c :: rest =>
      if c.isDigit then
        let d := (c.toNat - '0'.toNat)
        go (acc * 10 + d) rest
      else
        (acc, c :: rest)
    go 0 cs
  let parsePart (s : String) : Option Op :=
    match s.data with
    | [] => none
    | id :: rest =>
      let (n, _rest) := parseDigits rest
      match id with
      | 'A' => if n = 0 then none else some (Op.Absorb n)
      | 'S' => if n = 0 then none else some (Op.Squeeze n)
      | 'R' => some Op.Ratchet
      | 'H' => some Op.Hint
      | _ => none
  let opsList := (parts.drop 1).foldl (fun acc p =>
      match parsePart p with
      | some op => acc.push op
      | none => acc) (#[] : Array Op)
  -- simplify by merging consecutive Absorb/Squeeze
  let simplify (acc : Array Op) (op : Op) : Array Op :=
    match acc.back? with
    | some (Op.Absorb a) =>
        match op with
        | Op.Absorb b => acc.pop.push (Op.Absorb (a + b))
        | _ => acc.push op
    | some (Op.Squeeze a) =>
        match op with
        | Op.Squeeze b => acc.pop.push (Op.Squeeze (a + b))
        | _ => acc.push op
    | _ => acc.push op
  opsList.foldl simplify (#[] : Array Op)

end DomainSeparator

/-- Type class for byte-oriented domain separators.

Rust interface:
```rust
pub trait ByteDomainSeparator {
    fn add_bytes(self, count: usize, label: &str) -> Self;
    fn hint(self, label: &str) -> Self;
    fn challenge_bytes(self, count: usize, label: &str) -> Self;
}
```
-/
class ByteDomainSeparator (α : Type*) where
  /-- Add bytes to the domain separator (equivalent to absorb). -/
  addBytes : α → Nat → String → α
  /-- Add a hint to the domain separator. -/
  hint : α → String → α
  /-- Challenge bytes from the domain separator (equivalent to squeeze). -/
  challengeBytes : α → Nat → String → α

/-- Implementation of ByteDomainSeparator for DomainSeparator.

Rust implementation:
```rust
impl<H: DuplexSpongeInterface> ByteDomainSeparator for DomainSeparator<H> {
    #[inline]
    fn add_bytes(self, count: usize, label: &str) -> Self {
        self.absorb(count, label)
    }

    fn hint(self, label: &str) -> Self {
        self.hint(label)
    }

    #[inline]
    fn challenge_bytes(self, count: usize, label: &str) -> Self {
        self.squeeze(count, label)
    }
}
```
-/
instance {H : Type*} {U : Type} [SpongeUnit U] [DuplexSpongeInterface U H] :
    ByteDomainSeparator (DomainSeparator U H) where
  addBytes ds count label := ds.absorb count label
  hint ds label := ds.hint label
  challengeBytes ds count label := ds.squeeze count label
